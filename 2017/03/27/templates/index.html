<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="author" content="SofiaC++"><meta name="description"><title>Templates&mdash;Advanced C++</title><link href="/advanced-cpp/favicon.png" rel="icon"><link rel="alternate" href="/advanced-cpp/atom.xml" title="config.title" type="application/atom.xml"><link href="/advanced-cpp/bower_components/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet"><link href="/advanced-cpp/bower_components/bootstrap/dist/css/bootstrap-theme.min.css" rel="stylesheet"><link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/styles/default.min.css" rel="stylesheet"><style>body { padding-top: 50px; }</style></head><body><div class="container"><nav role="navigation" class="navbar navbar-inverse navbar-fixed-top"><div class="container"><div class="navbar-header"><button type="button" data-toggle="collapse" data-target="#navbar" class="navbar-toggle"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="/" class="navbar-brand">Advanced C++</a></div><div id="navbar" class="navbar-collapse collapse"><ul class="nav navbar-nav"><li><a href="/advanced-cpp/categories/news/">News</a></li><li><a href="/advanced-cpp/categories/slides/">Slides</a></li><li><a href="/advanced-cpp/about/">About</a></li></ul></div></div></nav><div class="page-header"><h1><a href="/advanced-cpp/">Advanced C++</a></h1><p id="site-slogan">Site for the Advanced C++ course at FMI</p></div><div class="row"><div class="col-sm-9"><section id="content"><article class="post"><h2>Templates</h2><div class="meta">27 Mar 2017 in <a href="/advanced-cpp/categories/slides/">slides</a>&ensp;</div><a href="/advanced-cpp/slides/templates.pdf" class="btn btn-large btn-primary"></a><original>Slides (Start here!)</original><a href="/advanced-cpp/slides/12_templates.html" class="btn btn-large btn-primary">Slide Show</a><p>include snippet</p>
<p>section
h1 Templates in action</p>
<p>section
:markdown
## Contents</p>
<pre><code>    1. Variadic templates
    2. Type traits
    3. Overload control
    4. SFINAE
    5. Type Erasure
    6. Static Polymorphism
    7. Expression templates
    8. Compile-time computation
</code></pre>
<p>section
section
:markdown
## Variadic templates</p>
<pre><code>        Allow much easier implemenation of templates with variable
        arguments, like `std::tuple`, `std::function`, etc.

section
    :markdown
        ### Parameter pack

    +snippet('12_templates/variadic.cxx', 'variadic')

section
    :markdown
        ### Parameter pack

        * can match remaining arguments
        * can be expanded
        * can not be stored in a variable or manipulated
section
    :markdown
        ### How to use a parameter pack

    +snippet('12_templates/variadic.cxx', 'recursion')

section
    :markdown
        ### How to use a parameter pack
    :cxx
        // T is a template parameter pack
        sizeof...(T)
        // count of types in T
section
    :markdown
        ### Sample

        A console that allows exection of arbitrary
        `std::function`s.

section
    +snippet('12_templates/console.cxx', 'execute')

section
    +snippet('12_templates/console.cxx', 'add-command')
    h4 So what does the magic wrap do?

section
    +snippet('12_templates/console.cxx', 'wrap0')

section
    +snippet('12_templates/console.cxx', 'wrap1')

section
    +snippet('12_templates/console.cxx', 'wrap2')

section
    :markdown
        ### Using variadic templates

        Based on [&quot;The Way of the Exploding Tuple&quot;] [1]

        [1]: http://channel9.msdn.com/events/GoingNative/2013/The-Way-of-the-Exploding-Tuple

section
    +snippet('12_templates/consolev.cxx', 'wrap')

section
    +snippet('12_templates/consolev.cxx', 'helper-0')

section
    +snippet('12_templates/consolev.cxx', 'helper-n')
</code></pre>
<p>section
section
:markdown
## Type Computations</p>
<pre><code>        * given existing type `T`, create a new one based on
          `T`
        * given `T` determine its properties (traits):
            * a pointer?
            * polymorphic?
            * Plain old data (POD)?
section
    :markdown
        ### Type traits

        The general name for the type computational facilities. The standard
        type traits are defined in `type_traits` header.

        Most of the type traits use template specialization.

section
    h3 Helpers:
    :cxx
        template &lt;typename T, T Value&gt;
        struct integral_constant {
            static T value = Value;
        };

        typedef integral_contant&lt;bool, false&gt; false_type;
        typedef integral_contant&lt;bool, true&gt; true_type;
        
section
    h3 Is pointer?
    :cxx
        template &lt;typename T&gt;
        struct is_pointer : false_type
        {};

        template &lt;typename T&gt;
        struct is_pointer&lt;T*&gt; : true_type
        {};

section
    h3 Add pointer
    :cxx
        template &lt;typename T&gt;
        struct add_pointer
        {
            typedef T* type;
        };
    :markdown
        The resulting new type is defined in `::type`.

section
    h3 Remove pointer
    :cxx
        template &lt;typename T&gt;
        struct remove_pointer
        {
            typedef T type;
        };
        
        template &lt;typename T&gt;
        struct remove_pointer&lt;T*&gt;
        {
            typedef T type;
        };

section
    :markdown
        ### `type_traits`

        * `is_arithmetic`
        * `is_fundamental`
        * `is_polymorphic`

section
    :markdown
        # Practice
        
        * use `std::false_type` and `std::true_type` for
          custom type traits
        * always define the result of type transformation in
          `type`
</code></pre>
<p>section
section
:markdown
## Controlling the overload set</p>
<pre><code>        The overload set is the set function overloads that are viable for
        resolving a call to a function

section
    :markdown
        ### Type traits and tags

section
    :cxx
        template &lt;typename T&gt;
        void Copy(T* source, T* destination, size_t count);

section
    :cxx
        template &lt;typename T&gt;
        void Copy(T* source, T* destination, size_t count) {
            for (size_t i = 0; i != count; ++i) {
                destination[i] = source[i];
            }
        }
    p.fragment.fade-in Can we do better?

section
    :cxx
        template &lt;typename T&gt;
        void Copy(T* source, T* destination, size_t count) {
            if ((T is POD)) {
                std::memcpy(destination, source, count * sizeof(T));
            }
            else {
                for (size_t i = 0; i != count; ++i) {
                    destination[i] = source[i];
                }
            }
        }

section
    :markdown
        ### Overloads

        Overloads are distinguished and chosen based on their arguments
        count and type. So we can add another argument and overload on it.

section
    :cxx
        struct isPOD {};
        struct nonPOD {};

        template &lt;typename T&gt;
        void Copy(T* source, T* destination, size_t count, isPOD) {
            std::memcpy(destination, source, count * sizeof(T));
        }

        template &lt;typename T&gt;
        void Copy(T* source, T* destination, size_t count, nonPOD) {
            for (size_t i = 0; i != count; ++i) {
                destination[i] = source[i];
            }
        }

section
    :cxx
        int a[10], b[10];
        Copy(a, b, 10, isPOD());
        // choses the memcpy implementation, because that is matching
        // overload

        std::string c[10], d[10];
        Copy(c, d, 10, isPOD()); // oops

section
    :markdown
        ### Not very nice
        
        * requires extra parameter for the client to use
        * error prone
        * requires definition of extra structs

section
    :cxx
        namespace detail
        {
            template &lt;typename T&gt;
            void Copy(T* source, T* destination, size_t count,
            std::true_type /*isPOD*/) {
                std::memcpy(destination, source, count * sizeof(T));
            }

            template &lt;typename T&gt;
            void Copy(T* source, T* destination, size_t count,
            std::false_type /*isPOD*/) {
                for (size_t i = 0; i != count; ++i) {
                    destination[i] = source[i];
                }
            }
        }
        template &lt;typename T&gt;
        void Copy(T* source, T* destination, size_t count)
            detail::Copy(source, destination, count, std::is_pod&lt;T&gt;());
        }
</code></pre>
<p>section
section
:markdown
## SFINAE</p>
<pre><code>        Substitution Failure Is Not An Error

        The compiler doesn't generate compiler error when a template
        paratemeter can not be substituted with a concrete type, it simply
        ignores the substutition.

section
    :cxx
        template &lt;typename T&gt;
        typename std::enable_if&lt;std::is_pod&lt;T&gt;::value, void&gt;::type
        Copy(T* source, T* destination, size_t count) {
            std::memcpy(destination, source, count * sizeof(T));
        }

        template &lt;typename T&gt;
        typename std::enable_if&lt;!std::is_pod&lt;T&gt;::value, void&gt;::type
        Copy(T* source, T* destination, size_t count) {
            for (size_t i = 0; i != count; ++i) {
                destination[i] = source[i];
            }
        }
section
    :cxx
        template &lt;bool Value, typename T&gt;
        struct enable_if {
        };

        template &lt;typename T&gt;
        struct enable_if&lt;true&gt; {
            typedef T type;
        };

section
    :cxx
        int s[10], d[10];
        Copy(s, d, 10);

    :markdown
        `int` is POD

        * `enable_if&lt;is_pod&lt;int&gt;::value, void&gt;::type` is
          `void` and the `memcpy` overload of `Copy` is viable
        * There is no such type in `enable_if&lt;!is_pod&lt;int&gt;::value,
          void&gt;`, so the substitution fails and the compiler silently
          ignores the *for* overload

section
    :cxx
        template &lt;typename T&gt;
        typename std::enable_if&lt;!std::is_pod&lt;T&gt;::value, void&gt;::type
        Copy(T* source, T* destination, size_t count) {
            for (size_t i = 0; i != count; ++i) {
                destination[i] = source[i];
            }
        }

section
    h3 SFINAE
    +snippet('12_templates/is_convertible.cxx', 'convertible')

section
    :markdown
        ### SFINAE
        
        Use `std::enable_if` to control the overload set of generic
        functions.
</code></pre>
<p>section
section
:markdown
## Type erasure</p>
<pre><code>section
    :markdown
        * *C++'98* doesn't have *C#* style delegates.
        * In *C++'11* they are provided by `std::function` and
          `std::bind`

        How they can be implemented?

section
    +snippet('12_templates/delegate0.cxx', 'delegate-fun')

section
    +snippet('12_templates/delegate0.cxx', 'delegate-method')

section
    +snippet('12_templates/delegate0.cxx', 'delegate-const-method')

section
    +snippet('12_templates/delegate0.cxx', 'functions')

section
    +snippet('12_templates/delegate0.cxx', 'usage')

section
    :markdown

        `DelegateFun&lt;void()&gt;` and `DelegateMethod&lt;A, void()&gt;`
        can not be a single class, because they have different
        template arguments

        Yet they have the same behavior - the `void ()` function.

        To make a usable delegate class, we need to erase the type
        difference between the types.
        
section
    +snippet('12_templates/delegate.cxx', 'impl')

section
    +snippet('12_templates/delegate.cxx', 'delegate-fun')

section
    +snippet('12_templates/delegate.cxx', 'delegate-method')

section
    +snippet('12_templates/delegate.cxx', 'delegate')

section
    +snippet('12_templates/delegate.cxx', 'delegate-ctor')

section
    +snippet('12_templates/delegate.cxx', 'delegate-value')

section
    :markdown

        The pattern for type erasure is to define a class that exposes the
        API and forwards all calls to a polymorphic object, which implements
        the concrete API.

        `std::function`, `boost::any` are probably the most famous examples
        of *type erasure*.

section
    :markdown
        The above implementation is pretty low performant.

        The reason for this is that a lot of small objects get allocated and
        always the actual function is away from the `Delegate` instance we
        have.

        This can be resolved by storing the concrete `DelegateFun` or
        `DelegateMethod` in a small buffer, directly in the `Delegate`
        class.
</code></pre>
<p>section
section
h1 Static Polymorphism</p>
<pre><code>section
    :markdown
        ## CRTP

        Curiously Recurring Template Pattern

    :cxx
        class Derived : public Base&lt;Derived&gt;
        {
        };

section
    p We have already seen that:
    :cxx
        struct Renderer : std::enabled_shared_from_this&lt;Renderer&gt;
        {};

        struct Texture : RefCounted&lt;Texture&gt;
        {};
section
    :markdown
        
        The *CRTP* allows the base template to use the derived type - it
        can call methods, create/destory instances and so on.

section
    :markdown
    
        ## Static polymorphism

        Using the derived class implementation though the base class
        interface

        * without virtual calls
        * compile-time

section
    h3 Runtime polymorphism
    :cxx
        struct JSONParser {
            virtual void array_begin() = 0;
            virtual void array_end() = 0;
            bool Parse() {
                //...
                char n = next();
                switch (n) {
                    case '[' : array_begin(); break;
                    case ']' : array_end(); break;
                    // ...
                }
            }
        };
    
section
    h3 Runtime polymorphism
    :cxx
        struct JSONMinifier : JSONParser {
            virtual void array_begin() override {
                output.put('[');
            }
            virtual void array_end() override {
                output.put(']');
            }
        };

    
section
    h3 Runtime polymorphism
    p.fragment.fade-in.
    
        We are making a virtual call for every token in the JSON file. And
        it is unlikely that we need more than a few different JSON parser
        types.

     
section
    h3 Static polymorphism
    :cxx
        template &lt;typename Derived&gt;
        struct JSONParser {
            Derived* This() {
                return static_cast&lt;Derived*&gt;(this);
            }
            bool Parse() {
                //...
                char n = next();
                switch (n) {
                    case '[' : This()-&gt;array_begin(); break;
                    case ']' : This()-&gt;array_end(); break;
                    // ...
                }
            }
        };
section
    h3 Static polymorphism
    :cxx
        struct JSONMinifier : JSONParser&lt;JSONMinifier&gt; {
            void array_begin() {
                output.put('[');
            }
            void array_end() {
                output.put(']');
            }
        };

section
    :markdown

        ## Barton-Nackman trick

        Characterized by an in-class friend function declared in the base
        class of a *CRTP*

section
    :cxx
        template &lt;typename T&gt;
        class comparable {
            friend bool operator &gt; (const T&amp; lhs, const T&amp; rhs) {
                return !(lhs &lt; rhs);
            }
            friend bool operator == (const T&amp; lhs, const T&amp; rhs) {
                return !(lhs &lt; rhs || lhs &gt; rhs);
            }
        };

        struct Poly : public comparable&lt;Poly&gt; {
            bool operator&lt;(const Poly&amp;rhs) const {
                //...
            }
        }
</code></pre>
<p>section
section
h1 Expression Templates</p>
<pre><code>section

    A techique for using types (templates) to represent part of an
    expression.

section
    
    The type (template) represents some kind of an operation with its
    operands and allows the result to be evaluated later or passed to a
    function (used itself as an operand).

section
    h3 A Polynom class
section
    +snippet('12_templates/exprtemp0.cxx', 'polynom')

section
    h4 A simple implementation

    :cxx
        template &lt;typename T&gt;
        Polynom&lt;T&gt; operator+(const Polynom&lt;T&gt;&amp; lhs, const Polynom&lt;T&gt;&amp; rhs) {
            auto power = std::max(lhs.power(), rhs.power();
            Polynom&lt;T&gt; result(power);
            for (auto i = 0; i != power; ++i) {
                result.set(i, lhs.get(i) + rhs.get(i));
            }
            return result;
        }
section
    h4 How many loops and temporaries?

    :cxx
        Polynom&lt;int&gt; a = { 1, 0, 1, 0, 1 }; // x^3 + x + 1
        Polynom&lt;int&gt; b = { 2, 2, 0, 2, 3 }; // 3*x^3 + 2*x^2 + 2*x + 2
        Polynom&lt;int&gt; c = { 42 };

        auto d = a + b + c;
        // compiled to:
        // t1 = a + b
        // t2 = t1 + c
        // d = t2
section
    ul
        li 2 temporaries
        li 2 loops!
        li heap allocations!
       
section
    h4 Expressions
    :cxx
        auto d = a + b + c;
        // With ET it compiled to:
        // Sum(a,b) t1 = a + b
        // Sum(Sum(a,b),c) t2 = t1 + c
        // d = t2 // create Polynom from Sum(Sum(a, b), c)

section
    :cxx
        // Pseudo code ahead
        auto power = std::max(a.power(), b.power(), c.power())
        Polynom&lt;int&gt; d(power);
        for (auto i = 0; i != power; ++i) {
            d.set(i, a.get(i) + b.get(i) + c.get(i));
        }
       
section
    ul
        li 2 temporaries
        li 1 loop!
        li 1 heap allocation!

section
    h4 Sum
section
    +snippet('12_templates/exprtemp0.cxx', 'sum')

section
    h4 Multiplication
section
    +snippet('12_templates/exprtemp0.cxx', 'mult')

section
    h4 Simple expressions
section
    +snippet('12_templates/exprtemp0.cxx', 'operators')

section
    h4 All possible expressions
section
    +snippet('12_templates/exprtemp0.cxx', 'all-operators')

section
    h3 Bonus question

    :markdown
    
        Why does the `Polynom` template have methods `get` and `set` instead
        of `operator[]`?
</code></pre>
<p>section
section
h1 Compile-time computation
section
a(href='http://cpptruths.blogspot.com/2011/07/want-speed-use-constexpr-meta.html')
| http://cpptruths.blogspot.com/2011/07/want-speed-use-constexpr-meta.html</p>
</article><div class="row-fluid"><div class="col-md-12"><hr><ul class="pagination"><li class="disabled"><a href="/advanced-cpp/#" title="Previous articles">&larr; Previous</a></li><li><a href="/advanced-cpp/2017/03/14/functional/" title="Next articles">Next &rarr;</a></li></ul></div></div></section></div><div class="col-sm-3"><nav role="navigation" class="navbar navbar-default"><div class="navbar-header"><div class="navbar-brand">Recent Posts</div></div><div class="clearfix"></div><ul class="nav navbar-stacked"><li><a href="/advanced-cpp/2017/03/27/templates/">Templates</a></li><li><a href="/advanced-cpp/2017/03/14/functional/">Functional C++</a></li><li><a href="/advanced-cpp/2017/03/13/errors/">Error handling</a></li><li><a href="/advanced-cpp/2017/03/12/library/">Libraries and API design</a></li><li><a href="/advanced-cpp/2017/03/12/namespaces/">Namespaces</a></li><li><a href="/advanced-cpp/2017/03/05/smart-resources/">Smart Resources</a></li><li><a href="/advanced-cpp/2017/03/01/smart-pointers/">Smart Pointers</a></li><li><a href="/advanced-cpp/2017/02/28/resources/">Resource Management</a></li></ul></nav></div></div><footer id="page-footer"><footer><div class="row-fluid"><div class="col-md-12"><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" width="88px" height="31px" src="/advanced-cpp/images/cc-by-sa.png"></a><br><span>Advanced C++</span> by<span> SofiaC++</span> is licensed under a&nbsp;<a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International
License
</a></div></div></footer><script src="/advanced-cpp/bower_components/jquery/dist/jquery.min.js"></script><script src="/advanced-cpp/bower_components/bootstrap/dist/js/bootstrap.min.js"></script><script src="/advanced-cpp/snippet.js"></script></footer></div></body></html>